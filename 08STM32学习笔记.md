# STM32课程介绍

一系列单片机的统称

32为微控制器（MCU）

ST（意法半导体）公司设计开发

以ARM Cortex-M 为核心

![image-20250523101310419](assets/image-20250523101310419.png)

**课程内容：**

![image-20250523101510964](assets/image-20250523101510964.png)

# 一：STM32概述

## 1.1关于ARM内核

STM32的处理器架构是ARM处理器架构：精简指令集计算机（RISC）

![image-20250523102820733](assets/image-20250523102820733.png)

## 1.2 什么是STM32

![image-20250523103102443](assets/image-20250523103102443.png)

![image-20250523103356231](assets/image-20250523103356231.png)

## 1.3 STM32 应用场景

物联网（IoT）internet of things

工业自动化

汽车电子

消费电子

医疗设备

![image-20250523103812379](assets/image-20250523103812379.png)

## 1.4 STM32系列MCU命名规则

![image-20250523104412329](assets/image-20250523104412329.png)

## 1.5 STM32 开发方式

**1.基于寄存器开发**

优点：代码执行效率高，对硬件理解深入，有利于新手学习STM32知识，更换其他芯片上手快。

缺点：开发效率低，代码移植不方便

**2.基于标准库函数开发**

优点：相比寄存器开发效率提高，相比寄存器开发难度降低，相比寄存器开发移植容易。

缺点：屏蔽一些硬件信息，不利于新手学习知识，官方已经停止对标准库的更新，新的芯片已经不提供标准库。

**3.基于HAL库函数开发**

优点：ST主推，支持力度大，开发工具持续更新，开发难度相比前面两种大大降低，移植极其容易。

缺点：屏蔽几乎所有硬件信息，不利于新手学习知识，只学HAL，学完之后基础知识不够牢固。当迁移到其他MCU设备时，一切都要重新学习。

**学习过程中：基于寄存器开发 + 基于HAL库函数开发**

## 1.6 STM32 开发工具

1. Keil MDK

![image-20250523110512263](assets/image-20250523110512263.png)

2. IAR

![image-20250523110609413](assets/image-20250523110609413.png)

3. STM32CubeIDE（ST官方推出）

![image-20250523110745180](assets/image-20250523110745180.png)

4. Clion（工具新星）

![image-20250523110949687](assets/image-20250523110949687.png)

![image-20250523111046111](assets/image-20250523111046111.png)

# 二：开发板简介

## STM32 最小系统

STM32单片机能工作的最小外围电路叫**最小系统**。

最小系统通常包括：STM32芯片、电源、时钟、下载调试和复位5部分组成。

### 2.电源

![image-20250523112853362](assets/image-20250523112853362.png)

![image-20250523113131049](assets/image-20250523113131049.png)

![image-20250523143504147](assets/image-20250523143504147.png)

### 3.时钟

![image-20250523143547298](assets/image-20250523143547298.png)

​	芯片内部可以有时钟，但是由于晶振没法集成到芯片里去，所有**芯片里的时钟一般是RC振荡电路**，这种时钟不够稳定，而外部接晶振这种方式，**它的时钟完全由物理特性决定的**，所有芯片一般都会接外部晶振。

### 4.复位

![image-20250523144242545](assets/image-20250523144242545.png)

### 5.下载调试

![image-20250523144435487](assets/image-20250523144435487.png)

# 三：点亮LED灯案例

## 3.1 需求描述

快速体验STM32开发：点亮LED1。

## 3.2硬件电路设计

![image-20250523150012878](assets/image-20250523150012878.png)

![image-20250523150028790](assets/image-20250523150028790.png)

说明：

（1）LED1连接的时端口PA0

（2）只要让PA0引脚输出低电平就可以点亮LED1。

## 3.3创建项目工程

### （1）创建需要的目录

![image-20250523150350831](assets/image-20250523150350831.png)

### （2）准备启动文件

### （3）创建项目工程

#### 3.3.1 创建工程准备

#### 3.3.2 工程配置

#### 3.3.3 编译配置

## 3.4软件设计

### 3.4.1 时钟配置

虽然系统时钟已经有了，但是还需要对各自模块的时钟做配置。 

PA端口时钟启动。

配置外设时钟使能寄存器（PCC_APB2ENR）

![image-20250523165456810](assets/image-20250523165456810.png)



![image-20250523165514844](assets/image-20250523165514844.png)

![image-20250523165528630](assets/image-20250523165528630.png)

![image-20250523160730529](assets/image-20250523160730529.png)

### 3.4.2 GPIO工作模式配置

![image-20250523160955889](assets/image-20250523160955889.png)

![image-20250523161134931](assets/image-20250523161134931.png)

PA端口配置低寄存器  PA1为 **通用推挽输出**

### 3.4.3 PA0输出低电平

![image-20250523161522244](assets/image-20250523161522244.png)

![image-20250523161409613](assets/image-20250523161409613.png)

**配置PA的输出数据寄存器**

### 3.4.4 用死循环保持状态

![image-20250523161553760](assets/image-20250523161553760.png)

## 3.5 使用标准库完成点灯程序

代码可读性会更高。

![image-20250523163844486](assets/image-20250523163844486.png)

## 3.6 操作寄存器方式的进化

  /*

​    把某位置 1  (0 位 1位 ...)

​      比如把 num 的第 2 位置 1

​        1. 得到一个数第 2 位是 1 其他都为 0

​          a =  0000 0100  是由 1<<2 得到

​        2. 让 num | a

   */

  /*

​    把某位置 0  (0位 1位 ...)

​      比如把 num 的第 2 位置 0

​        1. 得到一个数第 2 位是 0 其他都为 1

​          a =  1111 1011  是由 ~(1<<2) 得到

​        2. 让 num & a

   */

```c
int main(void)
// 第一次进化
{
	// 1. 配置时钟
    RCC->APB2ENR |= (1 << 2);
    // 2. GPIO工作模式配置  GPIOA->CRL = 0x03;
    GPIOA->CRL &= ~(1<<3); 
    GPIOA->CRL &= ~(1<<2); 
    GPIOA->CRL |= (1<<1); 
    GPIOA->CRL |= (1<<0);
    // 3. PA0输出低电平 GPIOA->ODR最低位为0
    GPIOA->ODR &= (1<<0);
}
```

```c
int main(void)
//第二次进化
{
	// 1. 配置时钟
    RCC->APB2ENR |= (1 << 2);
    
    // 2. GPIO工作模式配置  GPIOA->CRL = 0x03;
    GPIOA->CRL &= ~（(1<<3)|(1<<2)）; 
    GPIOA->CRL |= （(1<<1)|(1<<0)）;
    
    // 3. PA0输出低电平 GPIOA->ODR最低位为0
    GPIOA->ODR &= (1<<0);
}
```

```c
int main(void)
//第三次进化
{
	// 1. 配置时钟
    RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;
    // 2. GPIO工作模式配置  GPIOA->CRL = 0x03;
    GPIOA->CRL &= ~GPIO_CRL_CNF0; // CNF0
    GPIOA->CRL |= GPIO_CRL_MODE0; // MODE0
    
    // 3. PA0输出低电平 GPIOA->ODR最低位为0
    GPIOA->ODR &= ~GPIO_ODR_ODR0;
}
```

点亮三个灯

```c
int main(void)
//第三次进化
{
	// 1. 配置时钟
    RCC->APB2ENR |= RCC_APB2ENR_IOPAEN;
    // 2. GPIO工作模式配置  GPIOA->CRL = 0x03;
    GPIOA->CRL &= ~GPIO_CRL_CNF0; // CNF0
    GPIOA->CRL |= GPIO_CRL_MODE0; // MODE0
    
    GPIOA->CRL &= ~GPIO_CRL_CNF1; 
    GPIOA->CRL |= GPIO_CRL_MODE1; 
    
    GPIOA->CRH &= ~GPIO_CRH_CNF8; 
    GPIOA->CRH |= GPIO_CRH_MODE8; 
    
    // 3. PA0输出低电平 GPIOA->ODR最低位为0
    GPIOA->ODR &= ~GPIO_ODR_ODR0;
    GPIOA->ODR &= ~GPIO_ODR_ODR1;
    GPIOA->ODR &= ~GPIO_ODR_ODR8;
}
```

# 四：GPIO外设（片上外设）

片上外设：就在32单片机的这个芯片上。

## 4.1 GPIO概述

​	GPIO（General-purpose input/output），通用型输入输出。简单理解就是我们可以**控制输入输出**的STM32引脚，统称为GPIO。

​	GPIO存在的意义就是**用程序控制或读取**它们的**输出或输入**。

### 4.1.1 GPIO总体说明

​	STM32有多组GPIO，比如我们使用的芯片：STM32F103ZET6共有7组GPIO端口，他们分别是GPIOx（x从A-G），**每组控制16个引脚，**共有112个GPIO引脚。

​	每个引脚的电平是0-3.3V，部分引脚最高可以兼容到5V。

![image-20250523212226186](assets/image-20250523212226186.png)

### 4.1.2 GPIO的主要特点

（1）不同型号，IO口的数量可能不一样。

（2）快速翻转。最快可以达到每2个时钟周期翻转一次。（翻转指高低电平变换）（STM32F1系列最快可以达到50MHz的翻转速度）。

（3）每个IO都可以作为外部中断。

（4）支持8种工作模式。

### 4.1.3 GPIO的8种工作模式

GPIO端口的每个位（引脚）可以由 **软件** 分别 **配置** 成8种模式，当然对同一个引脚同一时间只能处于某一种模式中。

（1）输入浮空（Input floating）

（2）输入上拉（Input pull-up）

（3）输入下拉（Input-pull-down）

（4）模拟输入（Analog）

（5）通用开漏输出（Output open-drain）

（6）通用推挽式输出（Output push-pull）

（7）推挽式复用功能（Alternate function push-pull）

（8）开漏复用功能（Alternate function open-drain）

每个I/O端口位可以自由编程，然而I/O端口寄存器必须按 **32位字** 被访问。

**输出模式**  下可以 **控制端口输出** 高电平低电平，用于驱动LED，蜂鸣器等，如果是大功率器件（比如电机），还需要加上驱动器（小电流控制大电流）。

**输入模式** 下可以 **读取端口** 的高低电平，用于读取外接按键，外接模拟信号的输入，ADC电压采集，模拟通信协议接受数据等。

## 4.2 GPIO工作模式

### 4.2.1 GPIO每位的具体电路结构

![image-20250523213123693](assets/image-20250523213123693.png)

### 4.2.2 每种模式详解

#### 4.2.2.1 输出模式

##### 通用推挽输出：

一推一拉，输出1的时候，将VDD电流推出去；输出为0的时候，将外部的电流拉进来。

##### 推挽输出总结：

​	1.向设置/清除寄存器对应的设置位或清除位写1。

​	2.或者直接向输出寄存器对应位写1或0。

​	3.也可以从输入寄存器读取引脚状态。

​	4.工作时两个MOS管交替工作来驱动负载。输出1时，上部晶体管导通将电流推向负载；输出0时，下部晶体管导通，将电流拉回地线。所以叫推挽输出。

##### 通用开漏输出：

P-MOS管永远关闭，不生效。

![image-20250523220214908](assets/image-20250523220214908.png)

**输出0时**，与**推挽**状态一致，下部晶体管导通，将电流拉回地线，**对外表现输出0**。

![image-20250523220548247](assets/image-20250523220548247.png)

想输出1时，由于·**两个晶体管都不导通**，**对外表现为高阻态**。

这时想输出1，**需要加一个上拉电阻**，才能输出1.

![image-20250523220659188](assets/image-20250523220659188.png)

##### 开漏输出总结：

​	1.上部晶体管永远关闭。

​	2.可以输出0

​	3.如果要输出1必须接上拉电阻

##### 推挽输出和开漏输出的选择

![image-20250523221617376](assets/image-20250523221617376.png)

#### 4.2.2.2 复用输出模式

![image-20250524143130019](assets/image-20250524143130019.png)

#### 4.2.2.3 GPIO输入流程

![image-20250524143846396](assets/image-20250524143846396.png)

1.上图是输入电路，圈住部分为**钳位电路**，用于控制I/O口的输入电压，保护电路。

2.当外边·没有任何输入的时候，IO引脚悬空，对芯片内部来说呈现高阻态，这样的话电平是0还是1就不确定。

如果我们需要引脚不接电路时，**默认是1**的话，我们就**闭合上拉电阻开关**。

如果我们需要引脚不接电路时，**默认是0**的话，我们就**闭合下拉电阻开关**。

**施密特触发器整流规则**

![image-20250524144801200](assets/image-20250524144801200.png)

![image-20250524144707930](assets/image-20250524144707930.png)

​	（1）2个保护二极管的作用是保护我们的芯片不会由于电压过高或过低而烧毁。

​	VDD是接电源（3.3V），VSS接地（0V）。如果IO引脚的输入电压**高于VDD**的值到一定程度，**上方**保护二极管导通，则引脚电压被**拉低到VDD**。如果IO引脚的输入电压（负电压）**低于VSS**到一定程度，则**下方**保护二极管导通，电压被**拉高到VSS**。

​	（2）2个**开关**控制引脚在没有输入的时候是上拉，下拉还是浮空。当上面的开关闭合的时候，输入被拉高到高电平。当下面的开关闭合的时候，输入被拉低到低电平。如果两个都不闭合，输入就是悬空状态。两个同时闭合，就是费电了，不会这么做的。

​                                   ![image-20250524145341288](assets/image-20250524145341288.png)

​	（3）施密特（图中翻译成肖特基触发器应该是翻译错误，英文版手册是TTL Schmitt trigger）触发器是包含正反馈的比较器电路。可以对信号进行波形整形。

​     ![image-20250524145351032](assets/image-20250524145351032.png)

![image-20250524145357864](assets/image-20250524145357864.png)

​     

从施密特触发起出来的数据，进入到输入数据寄存器中，我们就可以从中读取数据了。

#### 4.2.2.4 模拟输入模式

![image-20250524145500387](assets/image-20250524145500387.png)

片上外设=ADC（模数转换）

当配置为模拟输入时：

（1）输出部分被禁止。

（2）**禁止施密特触发输入**，实现了每个模拟I/O引脚上的零消耗。施密特触发输出值被强置为0。

（3）弱上拉和下拉电阻被禁止。

（4）读取输入数据寄存器时数值永远为0。

## 4.3 与GPIO相关的7个寄存器（重要）

每个GPIO端口有7个相关的寄存器：

Ø 2个32位配置寄存器（GPIOx_CRL，GPIOx_CRH）。configuration register：配置寄存器

Ø 2个32位数据寄存器（GPIOx_IDR和GPIOx_ODR）。input data register 、output data register

Ø 1个32位置位/复位寄存器（GPIOx_BSRR）。bit set/reset register

Ø 1个16位复位寄存器（GPIOx_BRR）。bit reset register

Ø 1个32位锁定寄存器（GPIOx_LCKR）。configuration lock register 锁定GPIO配置寄存器

### 4.3.1  GPIOx_CRL（端口配置低寄存器）

GPIOx_CRL（Port configuration register low），x可以是A-G。

![image-20250524151941140](assets/image-20250524151941140.png)

该寄存器配置的每个GPIO的 0-7 这个8个位，所以叫低寄存器。

1）MODE：每个端口有2个MODE位进行控制。

00：输入模式（复位后的状态）

01：输出模式，最大速度10MHz 

10：输出模式，最大速度2MHz 

11：输出模式，最大速度50MHz

1）CNF：每个端口有2个CNF位进行控制。

（1）当MODE是00 （输入模式）

00：模拟输入模式 

01：浮空输入模式(复位后的状态) 

10：上拉/下拉输入模式 

11：保留 

（2）当MODE>00（输出模式）

00：通用推挽输出模式 

01：通用开漏输出模式 

10：复用功能推挽输出模式 

11：复用功能开漏输出模式

### 4.3.2  GPIOx_CRH（端口配置高寄存器）

GPIOx_CRH（Port configuration register high）。

该寄存器配置的是每个端口的 8-15引脚，配置方式和低位寄存器完全一样。

### 4.3.3 GPIOx_IDR（端口输入数据寄存器）

Port input data register

![image-20250524152051355](assets/image-20250524152051355.png)

保留位始终读为0。剩下的分别对应每个引脚的输入值。

### 4.3.4 GPIOx_ODR（端口输出数据寄存器）

Port output data register

![image-20250524153235634](assets/image-20250524153235634.png)

保留位始终读为0。剩下的分别对应每个引脚的输出值。

### 4.3.5 GPIOx_BSRR（端口位设置/清除寄存器）

Port bit set/reset register

![image-20250524153316195](assets/image-20250524153316195.png)

![image-20250524154244769](assets/image-20250524154244769.png)

（1）BRy高16位是用清除对应的数据输出寄存器的位（0-15）的值：设置为0不影响，设置为1会清除ODR对应的位的值（置为0）。

（2）BSy低16位是用设置对应的数据输出寄存器的位（0-15）的值：设置为0不影响，设置为1会设置ODR对应的位的值（置为1）。

**（3）如果同时设置BRy和BSy的对应位，BSy位起作用。**

### 4.3.6GPIOx_BRR（端口位清除寄存器）

这个寄存器具有了**GPIOx_BSRR****一半的功能：清除**。

![image-20250524153435967](assets/image-20250524153435967.png)

### 4.3.7 GPIOx_LCKR（端口配置锁定寄存器）

Port configuration lock register

![image-20250524153508614](assets/image-20250524153508614.png)

![image-20250524155435246](assets/image-20250524155435246.png)

该寄存器用来**锁定端口位的配置**，针对CRL和CRH。位[15:0]用于锁定GPIO端口的配置。



位[16]LCKK：锁键（LOCK key）

该位可随时读出，它只可通过锁键写入序列修改

​	0：端口配置锁键位[15:0]激活。

​	1：端口配置锁键位被激活，至下次系统复位前GPIOx_LCKR寄存器被锁住。

第16位用来激活锁定寄存器，必须按照规定的时序来操作才行: 写1 -> 写0 -> 写1 -> 读0 -> 读1。

最后一位读操作可以省略，但可以用来确认锁键是否已经被激活。

在规定的写入操作期间，不能改变LCKR[15:0]。当对相应的端口位执行了LOCK序列后，在下次系统复位之前将不能再更改端口位的配置。



位[15:0]：

每个锁定位锁定控制寄存器（CRL，CRH）中相应的4个位（CNF2位和MODE2位）。

对0-15位：

​	0：不锁定对应端口的配置。

​	1：锁定对应端口的配置。

## 4.4 GPIO案例：流水灯

### 4.4.1 需求描述

​	在3个LED上实现流水灯效果。

### 4.4.2 硬件电路设计

![image-20250525123650182](assets/image-20250525123650182.png)

![image-20250525123655276](assets/image-20250525123655276.png)

### 4.4.3 软件设计（寄存器）

#### 4.5.3.1 配置

1）配置启动文件

![image-20250525124304116](assets/image-20250525124304116.png)

#####  1.**stm32f10x.h（设备头文件）**

- 作用：
  - **寄存器映射**：定义STM32外设（如GPIO、USART、SPI等）的寄存器地址和位字段，通过结构体提供访问接口。
  - **设备配置**：根据目标芯片型号（如STM32F10X_HD）启用对应的宏，区分不同内存密度的设备。
  - **时钟配置**：设置外部晶振频率（`HSE_VALUE`），影响系统时钟初始化。
- 重要性：
  - 提供硬件抽象层，使开发者无需直接操作内存地址，而是通过结构体成员访问外设寄存器。
  - 确保代码可移植性，适配不同STM32型号。

------

##### **2. system_stm32f10x.c/h（系统初始化文件）**

- 作用：
  - **系统时钟初始化**：`SystemInit()`函数配置PLL、时钟源（HSI/HSE）、总线分频（AHB/APB），设置Flash延迟以适应高频时钟。
  - **时钟动态更新**：`SystemCoreClockUpdate()`根据当前时钟源更新`SystemCoreClock`变量，反映实际HCLK频率。
- 重要性：
  - 确保CPU和所有外设以正确的时钟频率运行。
  - 影响系统性能和功耗，高频需更高Flash等待周期以避免访问错误。

------

##### **3. core_cm3.c/h（CMSIS核心文件）**

- 作用：
  - **内核寄存器访问**：定义SCB、SysTick、NVIC等内核外设的寄存器结构体及位操作宏。
  - **内联函数**：提供原子操作（如`__LDREXW`/`__STREXW`）、字节序转换（`__REV`）等底层功能。
  - **编译器适配**：通过不同编译器的内联汇编实现跨平台兼容。
- 重要性：
  - 标准化Cortex-M3内核操作接口，确保代码在不同工具链（如Keil、IAR、GCC）下行为一致。
  - 支持中断控制和系统级功能（如休眠模式）。

------

##### **4. 启动文件（如startup_stm32f10x_hd.s）**

- 作用：
  - **堆栈初始化**：设置主堆栈指针（MSP）和进程堆栈指针（PSP）。
  - **向量表配置**：定义中断服务例程（ISR）的入口地址，复位后跳转到`SystemInit`和`main`函数。
  - **硬件初始化**：调用`SystemInit`配置系统时钟，初始化.data（已初始化变量）和.bss（未初始化变量）段。
- 重要性：
  - 确保芯片上电后正确初始化运行环境，避免未定义行为。
  - 中断向量表的位置需与链接脚本匹配，否则无法响应中断。

------

##### **5. 链接脚本（.ld/.sct文件）**

- 作用：
  - 定义内存布局（Flash/RAM的起始地址和大小）。
  - 分配代码、数据、堆栈等段的位置。
- 重要性：
  - 确保程序正确烧录到目标设备的存储区域。
  - 影响代码执行效率和内存利用率。

------

##### **配置步骤与注意事项**

1. **选择设备型号**：
   在`stm32f10x.h`中启用对应的宏（如`STM32F10X_HD`），匹配目标芯片的内存密度。
2. **配置时钟源**：
   - 修改`HSE_VALUE`以匹配外部晶振频率（如8MHz或25MHz）。
   - 在`system_stm32f10x.c`中选择系统时钟频率（如`SYSCLK_FREQ_72MHz`），影响PLL倍频参数。
3. **启动文件适配**：
   - 根据芯片型号选择正确的启动文件（如`startup_stm32f10x_hd.s`对应高密度设备）。
   - 确认向量表偏移（`VECT_TAB_OFFSET`）与应用程序地址一致（如启用Bootloader时需调整）。
4. **标准外设库启用**：
   若使用ST标准库函数，需定义`USE_STDPERIPH_DRIVER`宏，否则需直接操作寄存器。
5. **链接脚本调整**：
   根据实际Flash和RAM大小调整链接脚本，避免内存溢出。

### 4.4.4 main.c代码基本实现

```c
#include "stm32f10x.h"
void Delay_us(uint16_t us);
void Delay_ms(uint16_t ms);
int main(void)
{
    // 1. 时钟配置
    RCC->APB2ENR |= RCC_APB2ENR_IOPAEN; // 使能GPIOA时钟

    // 2. GPIO工作模式配置：推挽输出模式
    GPIOA->CRL &= ~GPIO_CRL_CNF0; 
    GPIOA->CRL &= ~GPIO_CRL_MODE0; 

    GPIOA->CRL &= ~GPIO_CRL_CNF1; 
    GPIOA->CRL &= ~GPIO_CRL_MODE1; 

    GPIOA->CRH &= ~GPIO_CRH_CNF8; 
    GPIOA->CRH &= ~GPIO_CRH_MODE8; 

    // 3. PA0,PA1,PA8输出高电平
    GPIOA->ODR |= GPIO_ODR_ODR0; // PA0输出高电平
    GPIOA->ODR |= GPIO_ODR_ODR1; //PA1输出高电平 
    GPIOA->ODR |= GPIO_ODR_ODR8; // PA8输出高电平

    // 4.循环执行流水灯
    while(1)
    {
        // 4.1 LED1
        GPIOA->ODR &= ~GPIO_ODR_ODR0; // PA0输出低电平
        Delay_ms(500); // 延时500ms
        GPIOA->ODR |= GPIO_ODR_ODR0; // PA0输出高电平
        // 4.2 LED2
        GPIOA->ODR &= ~GPIO_ODR_ODR1; // PA1输出低电平
        Delay_ms(500); // 延时500ms
        GPIOA->ODR |= GPIO_ODR_ODR1; // PA1输出高电平
        // 4.3 LED3
        GPIOA->ODR &= ~GPIO_ODR_ODR8; // PA8输出低电平
        Delay_ms(500); // 延时500ms
        GPIOA->ODR |= GPIO_ODR_ODR8; // PA1输出高电平
    }
}

// 延时函数,微妙作为单位，利用系统嘀嗒定时器，72MHz
// 1. 72MHz时钟频率，1us=72个时钟周期，一次嘀嗒=1/72（us）
void Delay_us(uint16_t us)
{
    // 1. 装载一个计数值
    SysTick->LOAD = us * (72 - 1);

    // 2.配置，使用系统时钟（1），技术结束不产生中断（0），使能定时器（1）
    SysTick->CTRL = 0x05;
    // 3. 等待计数结束,判断CTRL标志位COUNTFLAG是否为1
    while((SysTick->CTRL & SysTick_CTRL_COUNTFLAG) == 0)
    {}
    // 4.关闭嘀嗒定时器
    SysTick->CTRL &= ~SysTick_CTRL_ENABLE; 
}

void Delay_ms(uint16_t ms)
{
    while(ms--)
    {
        Delay_us(1000); // 延时1ms
    }
}

```

### 4.4.5 代码结构优化

功能模块拆分

main.c：

```c
#include "led.h"
#include "delay.h"


int main(void)
{
    // 1.LED初始化
    LED_Init(); 
    // 2. 定义一个LED数组
    uint16_t leds[] = {LED1, LED2, LED3};
    // 4.循环执行流水灯
    while(1)
    {
        for (uint8_t i=0; i<3; i++)
        {
            LED_On(leds[i]);   // 输出低电平
            Delay_ms(500);  // 延时500ms
            LED_Off(leds[i]);  // 输出高电平
        }
    }
}
```

delay.c：

```c
#include "delay.h"

// 延时函数,微妙作为单位，利用系统嘀嗒定时器，72MHz
// 1. 72MHz时钟频率，1us=72个时钟周期，一次嘀嗒=1/72（us）
void Delay_us(uint16_t us)
{
    // 1. 装载一个计数值
    SysTick->LOAD = us * (72 - 1);

    // 2.配置，使用系统时钟（1），技术结束不产生中断（0），使能定时器（1）
    SysTick->CTRL = 0x05;
    // 3. 等待计数结束,判断CTRL标志位COUNTFLAG是否为1
    while((SysTick->CTRL & SysTick_CTRL_COUNTFLAG) == 0)
    {}
    // 4.关闭嘀嗒定时器
    SysTick->CTRL &= ~SysTick_CTRL_ENABLE; 
}
void Delay_ms(uint16_t ms)
{
    while(ms--)
    {
        Delay_us(1000); // 延时1ms
    }
}
void Delay_s(uint16_t s)
{
    while(s--)
    {
        Delay_ms(1000); // 延时1s
    }

}

```

led.c: 

```c
#include "led.h"

// 初始化
void LED_Init(void) // 初始化LED灯
{
    // 1. 时钟配置
    RCC->APB2ENR |= RCC_APB2ENR_IOPAEN; // 使能GPIOA时钟

    // 2. GPIO工作模式配置：推挽输出模式
    GPIOA->CRL &= ~GPIO_CRL_CNF0; 
    GPIOA->CRL &= ~GPIO_CRL_MODE0; 

    GPIOA->CRL &= ~GPIO_CRL_CNF1; 
    GPIOA->CRL &= ~GPIO_CRL_MODE1; 

    GPIOA->CRH &= ~GPIO_CRH_CNF8; 
    GPIOA->CRH &= ~GPIO_CRH_MODE8; 

    // 3. PA0,PA1,PA8输出高电平，默认关灯
    LED_Off(LED1); // PA0输出高电平
    LED_Off(LED2); // PA1输出高电平
    LED_Off(LED3); // PA8输出高电平
}

// 控制某一个LED的开关
void LED_On(uint16_t led) // 点亮LED
{
    GPIOA->ODR &= ~led;
}
void LED_Off(uint16_t led) // 熄灭LED
{
    GPIOA->ODR |= led;
}

// 根据当前状态进行反转
void LED_Toggle(uint16_t led) // 反转LED状态
{
    // 判断LED的状态
    if ((GPIOA->IDR & led) == 0) // 如果LED是亮的
    {
        LED_Off(led); // 熄灭LED
    }
    else // 如果LED是灭的
    {
        LED_On(led); // 点亮LED
    }
}

// 对一组LED灯，全开全关
void LED_OnAll(uint16_t leds[], uint8_t size) // 点亮所有LED
{
    uint8_t i = 0;
    for (; i < size; i++)
    {
        LED_On(leds[i]);
    }
}
void LED_OffAll(uint16_t leds[], uint8_t size) // 关闭所有LED
{
    uint8_t i = 0;
    for (; i < size; i++)
    {
        LED_Off(leds[i]);
    }
}

```

### 4.4.6 课后练习

![image-20250525150651485](assets/image-20250525150651485.png)

#### 4.4.6.1 往返流水灯

##### 4.4.6.1.1

main.c:

```c
#include "led.h"
#include "delay.h"


int main(void)
{
    // 1.LED初始化
    LED_Init(); 
    // 2. 定义一个LED数组
    uint16_t leds[] = {LED1, LED2, LED3};
    // 4.循环执行流水灯
    while(1)
    {
        for (uint8_t i=0; i<3; i++)
        {
            LED_On(leds[i]);   // 输出低电平
            Delay_ms(500);  // 延时500ms
            LED_Off(leds[i]);  // 输出高电平
        }
        // 让LED2开关一次，实现反向流水灯效果
        LED_On(LED2);    // 输出低电平
        Delay_ms(500);      // 延时500ms
        LED_Off(LED2);   // 输出高电平
    }
}
```

# 五：总体架构和时钟系统

## 5.1 STM32总体架构

![image-20250525154050430](assets/image-20250525154050430.png)

**FSMC也是被动单元。**

![image-20250525161803609](assets/image-20250525161803609.png)

**总线矩阵作用：用来做一个调度，确定当前这个总线由谁来用。**

![image-20250525162144770](assets/image-20250525162144770.png)

## 5.2 时钟系统

### 5.2.1 时钟树

在STM32中有3种不同的时钟源用来驱动系统时钟(SYSCLK)：

​	（1）HSI振荡器时钟（High Speed Internal oscillator，高速内部时钟）

​	（2）HSE振荡器时钟（High Speed External（Oscillator / Clock），高速外部时钟）

​	（3）PLL时钟（Phase Locked Loop 锁相环/倍频器）

还有2种2级时钟：

​	（4）LSI时钟（Low Speed Internal，低速内部时钟）

​	（5）LSE时钟（Low Speed External oscillator，低速外部时钟）。

为什么提供这么多的时钟？节能！高速设备接高速时钟，低速设备接低速时钟，可以最大程度的达到节能效果。详见下图时钟树。

![image-20250525162425955](assets/image-20250525162425955.png)

**OSC：**振荡器

**OSC_OUT**  和 **OSC_IN**用来接外部晶振的

**OSC32_OUT**  和 **OSC32_IN**用来接外部晶振的

**MCO**：主时钟，可以直接做输出

**PLL**：Phase Locked Loop锁相环，作用：倍频

### 5.2.2 各个时钟介绍

#### 1）HSE时钟

​	高速外部时钟是由外部时钟源提供，目前几乎所有的STM32单片机的设计都是在外部接一个**8MHz**的晶振，经过**PLL倍频（9倍频）**后得到一个**72MHz**的系统时钟。我们系统默认就是这个时钟。这个在启动文件可以看到。

![image-20250525164523851](assets/image-20250525164523851.png)

![image-20250525164550081](assets/image-20250525164550081.png)

#### 2）HSI时钟

​	HSI时钟信号由内部**8MHz的RC振荡器**产生，可直接作为系统时钟或在2分频后作为PLL输入。HSI RC振荡器能够在不需要任何外部器件的条件下提供系统时钟。它的启动时间比HSE晶体振荡器短。然而，即使在校准之后它的时钟频率**精度仍较差**。

![image-20250525164650170](assets/image-20250525164650170.png)

#### 3）PLL

​	内部PLL用来倍频**HSI RC**的输出时钟或**HSE**晶体输出时钟。**PLL的设置必须在其被激活前完成。一旦PLL被激活，这些参数就不能被改动。**如果PLL中断在时钟中断寄存器里被允许，当PLL准备就绪时，可产生中断申请。

​	PLL时钟一般都是对外部的**8MHz的时钟信号经过9倍频后**，得到**72MHz的时钟频率**，这是STM32F1系列允许的最高时钟频率。

![image-20250525164800327](assets/image-20250525164800327.png)

#### 4）LSE时钟

​	LSE晶体是一个32.768kHz的低速外部晶体或陶瓷谐振器。它为**实时时钟RTC**或者其他定时功能提供一个低功耗且精确的时钟源。

​	LSE是**不能驱动系统时钟**的。

![image-20250525164841264](assets/image-20250525164841264.png)

#### 5）LSI时钟

​	**LSI RC**担当一个低功耗时钟源的角色，**它可以在停机和待机模式下保持运行**，**为独立看门狗和自动唤醒单元提供时钟。**LSI时钟频率大约40kHz（在30kHz和60kHz之间）。

​	LSI也是**不能驱动系统时钟**的。

![image-20250525164934403](assets/image-20250525164934403.png)

# 六：HAL库开发入门

# 6.1 HAL介绍

### 1）为什么要学习HAL库开发

​	寄存器开发效率比较低，在工作中如果想**快速开发**还是要会用到HAL库开发。

​	HAL库是目前ST主力推广的开发方式，所以你如果还**要用ST的芯片**，会使用HAL库开发是势在必行的。而且最最关键的是，使用HAL开发有诸多的好处。

​	目前，HAL库已经支持STM32全线产品。

### 2）什么是HAL库

​	HAL库的全称是Hardware Abstraction Layer，翻译成**硬件抽象层**。HAL库是ST为STM32最新推出的抽象层嵌入式软件，可以更好的确保跨STM32产品的最大可移植性。该库提供了一整套一致的中间件组件，如RTOS，USB，TCP/IP和图形等。

​	HAL库是基于一个非限制性的BSD许可协议（Berkeley Software Distribution）而发布的开源代码。 ST制作的中间件堆栈（USB主机和设备库，STemWin）带有允许轻松重用的许可模式，只要是在ST公司的MCU 芯片上使用，库中的中间件(USB 主机/设备库，STemWin)协议栈即被允许随便修改，并可以反复使用。至于基于其它著名的开源解决方案商的中间件（FreeRTOS，FatFs，LwIP和PolarSSL）也都具有友好的用户许可条款。

### 3）CMSIS和HAL库的关系

​	CMSIS（Cortex Microcontroller Software Interface Standard）是 Cortex-M 处理器系列的与供应商无关的硬件抽象层。它是ARM公司制定的一个标准。它可以为处理器和外设实现一致且简单的软件接口，从而简化软件的重用、缩短微控制器新开发人员的学习过程，并缩短新设备的上市时间。简单来说，就是ARM公司制定标准，芯片厂商按照此标准编写相应的程序，实现统一的接口，方便开发人员的使用。

## 6.2 HAL库开发环境搭建

## 6.3 LED流水灯案例（HAL库）

### 6.3.1 需求描述

​	实现LED流水灯。用的GPIOA的 0、1、8口。

### 6.3.2  硬件电路设计

![image-20250526105935078](assets/image-20250526105935078.png)

![image-20250526105940525](assets/image-20250526105940525.png)

### 6.3.3 软件设计

#### 6.3.3.1 创建HAL库工程

# 七：STM32的中断系统

## 7.1 中断概述

### 7.1.1 中断的概念

​	在主程序运行过程中，出现了特定事件，使得CPU暂停当前正在运行的程序，转而去处理这个事件，等这个事件处理完成之后，CPU再回到刚才被打断的位置继续处理，这就是中断。

​	那个打断CPU执行的特定事件，我们一般称之为**中断源**。被中断源打断的位置我们称为**断点**。处理特定事件的过程，我们称为执行**中断处理程序**。

![image-20250526151652246](assets/image-20250526151652246.png)

​	正在执行中断程序的时候，这个时候有可能被另外一个中断源给中断，CPU转而去执行另外一个中断源的中断处理程序，这叫**中断嵌套**。

​	中断B能否打断中断A，要看他们的优先级，优先级高的可以打断优先级低的，优先级低的无法打断优先级高的。

![image-20250526152407078](assets/image-20250526152407078.png)

​	中断源可以是外部的，也可以是内部的。外部的叫**外部中断源**，内部的叫**内部中断源（内部的中断有时候也叫异常）**。

### 7.1.2 为什么需要中断

​	对单片机系统来说，**中断至关重要**。

​	比如我们要检测按键是否按下，**如果没有中断，则需要循环的方式不断的去检测按键对应的IO口的电平，这是比较耗费CPU的时间的（轮询）**。如果要检测的更多的话，CPU有可能会导致阻塞。

​	有了中断事情就变的简单了，主程序不需要循环不断的去检测按键，当有按键按下的时候，CPU执行被打断，去执行按键处理程序就行了。当没有按键按下的时候，CPU完全可以正常执行代码，丝毫不受任何的影响。

### 7.1.3 STM32的中断

​	Cortex-M3内核支持**256个**中断，其中包含了16个内核中断和240个外部中断，并且具有256级的可编程中断设置。

​	一般情况下，芯片厂商会对**Cortex-M3**的中断进行裁剪。

​	**STM32有84个中断**，包括16个内核中断和68个可屏蔽中断，具有16级可编程的中断优先级。

​	**STM32F103**系列**70**个中断，有10个内核中断和60个可编程的外部中断。

​	下面的列表中，灰色背景的是内部中断（或者异常），其他的为外部中断。

下图地址里存放的是**对应中断服务程序的入口地址**。

![image-20250526153036744](assets/image-20250526153036744.png)

![image-20250526153042377](assets/image-20250526153042377.png)

![image-20250526153048494](assets/image-20250526153048494.png)

![image-20250526153053999](assets/image-20250526153053999.png)

### 7.1.4 STM32的中断体系架构

所有的中断请求都要发给内核，打断内核当前正在处理的程序。

​											->内核其他控件

NVIC嵌套向量中断控制器：**管理中断优先级**		->片上外设

​											->外部中断  

EXTI接20根线，处理20个不同的外部中断来源。

![image-20250526155536445](assets/image-20250526155536445.png)

### 7.1.5 NVIC嵌套向量中断控制器

#### 1）NVIC的介绍

​	NVIC（Nested vectored interrupt controller嵌套向量中断控制器）和处理器核的接口紧密相连，可以实现低延迟的中断处理和高效地处理中断。嵌套向量中断控制器管理着包括内核异常，外部中断等**所有中断**。由NVIC决定哪个中断的处理程序交给CPU来执行。

​	**每一个外部中断**都可以**被使能**或者**禁止**，并且可以被设置为**挂起状态（产生中断，但由于优先级较低，在等待）**或者清除状态。处理器的中断可以是**电平形式的**，也可以是**脉冲形式的**，这样中断控制器就可以处理任何中断源。

​	16个IO的中断与PVD(电源电压检测)，RTC(实时时钟)，USB，以太网检测这20个外部中断会通过EXTI来控制，然后交给NVIC。其他中断都是直接交给NVIC来处理。

#### 2）中断优先级

​	NVIC为了方便管理中断，可以通过软件给每个中断设置优先级。NVIC用4个位来控制优先级，值小的优先级高。把优先级分为两种：**抢占优先级（谁能打断谁）**和**响应优先级（同时等待的时候，先去相应谁）**。

​	规则：

​	Ø 优先级值越小，优先级越高。

​	Ø 如果不设置优先级，则默认优先级为0。

​	Ø 先比较抢占优先级。抢占优先级高的可以打断抢占优先级低的。

​	Ø 若抢占优先级一样，再比较响应优先级。但是响应优先级不会导致中断嵌套。

​	Ø 若抢占优先级一样的同时挂起，则优先处理**响应抢占优先级高**的。

​	Ø 若挂起的优先级（抢占和响应）都一样，则查找中断向量表，值小的先响应。

​	NVIC对优先级分了5组，在程序中先对中断进行分组，而且分组只能分一次，若多次分，只有最后一次生效。

![image-20250526163117293](assets/image-20250526163117293.png)

| **分组** |   **抢占优先级**   |   **响应优先级**   |
| :------: | :----------------: | :----------------: |
|  **0**   |  0位 取值范围：0   | 4位 取值范围：0-15 |
|  **1**   | 1位 取值范围：0-1  | 3位 取值范围：0-7  |
|  **2**   | 2位 取值范围：0-3  | 2位 取值范围：0-3  |
|  **3**   | 3位 取值范围：0-7  | 1位 取值范围：0-1  |
|  **4**   | 4位 取值范围：0-15 |  0位 取值范围：0   |

### 7.1.6 外部中断控制器EXTI

底层电路：

![image-20250526163234626](assets/image-20250526163234626.png)

具体流程：

输入线来输入信号->产生中断请求（下降沿触发 或者 上升沿触发）-> 请求挂起寄存器置1 -> 如果没有屏蔽 -> 给到NVIC -> 交给内核处理（调用中断服务程序）-> 处理完请求后，将请求挂起寄存器置0

![image-20250526164058908](assets/image-20250526164058908.png)

![image-20250526164142454](assets/image-20250526164142454.png)

某个中断在使用之前，需要**配置上升沿触发还是下降沿触发**，**配置中断屏蔽寄存器**。当中断程序执行完成之后，程序还需要**对请求挂起寄存器置0**。

## 7.2 中断案例：检测按键按下

### 7.2.1 需求描述

​	利用外部中断检测按键KEY3，当按键按下，翻转LED1显示。

### 7.2.2 硬件电路设计

#### 7.2.2.1 LED1的硬件电路

![image-20250526164548398](assets/image-20250526164548398.png)

![image-20250526164552658](assets/image-20250526164552658.png)

#### 7.2.2.2 KEY的硬件电路

![image-20250526164615114](assets/image-20250526164615114.png)

![image-20250526164619464](assets/image-20250526164619464.png)

​	说明：

​	（1）PF10对应的是KEY_3(SW5),我们可以设置PF10的模式为**下拉输入**，则当按键没有按下的时候是低电平，当按键按下的时候是高电平。

​	（2）由于按键没有设置硬件防抖，则我们需要软件设计防抖。一般延时10-15ms即可实现软件防抖。

### 7.2.3 软件设计（寄存器）

#### 7.2.3.1 中断检测按键按下案例用到的寄存器详解

##### 7.2.3.1.1 时钟使能

###### 1.1 代码

```c
    /* 1 开启时钟 (EXTI和NVIC时钟始终开启，无需手动开启)*/
    /* 1.1 开启 GPIOF 时钟 */
    RCC->APB2ENR |= RCC_APB2ENR_IOPFEN;
    /* 1.2 开启AFIO时钟 */
    RCC->APB2ENR |= RCC_APB2ENR_AFIOEN;

```

###### 1.2 寄存器

![image-20250526173751828](assets/image-20250526173751828.png)

![image-20250526173756077](assets/image-20250526173756077.png)

![image-20250526173800058](assets/image-20250526173800058.png)

##### 7.2.3.1.2 GPIO模式配置

###### 2.1 代码

```c
    /* 2 配置GPIO  设置为输入 下拉(cnf: 10 mode: 00) 。另外还需要把ODR寄存器对应的位设为0  (1=上拉)*/
    GPIOF->CRH &= ~GPIO_CRH_MODE10;
    GPIOF->CRH |= GPIO_CRH_CNF10_1;
    GPIOF->CRH &= ~GPIO_CRH_CNF10_0;
    GPIOF->ODR &= ~GPIO_ODR_ODR10;

```

###### 2.2 寄存器

![image-20250526173853824](assets/image-20250526173853824.png)

![image-20250526173857252](assets/image-20250526173857252.png)

![image-20250526173927668](assets/image-20250526173927668.png)

##### 7.2.3.1.3 配置AFIO引脚复用

###### 3.1 代码

```c
    /* 3  配置 AFIO, 用于引脚复用为外部中断  PF10 */
	AFIO->EXTICR[2] |= AFIO_EXTICR3_EXTI10_PF;
```

###### 3.2 寄存器

![image-20250526174115321](assets/image-20250526174115321.png)

7.2.3.1.4 配置EXTI

###### 4.1 代码

```c
    /* 4. 配置 EXTI */
    /* 4.1 PG0的上升沿触发中断   */
    EXTI->RTSR |= EXTI_RTSR_TR10;
    /* 4.2 开启 EXTI10 线 */
    EXTI->IMR |= EXTI_IMR_MR10;
```

###### 4.2 寄存器

RTSR：rising trigger selection register

FTSR：falling trigger selection register（下降沿触发选择寄存器）

![image-20250526174211739](assets/image-20250526174211739.png)

IMR：interrupt masked（带个面具，屏蔽起来） register

![image-20250526174233187](assets/image-20250526174233187.png)

##### 7.2.3.1.5 清除中断标志位

###### 5.1 代码

```c
    /* 清除中断标志. 写1清除中断 */
    EXTI->PR |= EXTI_PR_PR10;
```

###### 5.2 寄存器

PR：pending（悬而未决，待定） register：对应位写1清零。

![image-20250526174323929](assets/image-20250526174323929.png)