# 1.单片机C语言：



![image-20250513083156149](assets/image-20250513083156149.png)

![image-20250513083243921](assets/image-20250513083243921.png)

## C51特有的数据类型：

![image-20250513154517347](assets/image-20250513154517347.png)

![image-20250513154754150](assets/image-20250513154754150.png)

![image-20250513154902125](assets/image-20250513154902125.png)

![image-20250513154936143](assets/image-20250513154936143.png)

![image-20250513155020501](assets/image-20250513155020501.png)

## C51变量的特殊属性：

![image-20250513155312850](assets/image-20250513155312850.png)

![image-20250513155506053](assets/image-20250513155506053.png)

![image-20250513155718350](assets/image-20250513155718350.png)

**C51变量存储的默认模式：**

![image-20250513161249487](assets/image-20250513161249487.png)

![image-20250513161534010](assets/image-20250513161534010.png)

**1.使用库实现对绝对地址的访问：**

![image-20250513161628056](assets/image-20250513161628056.png)

![image-20250513162411449](assets/image-20250513162411449.png)

**2.通过指针实现对绝对地址的访问：**

![image-20250513163012063](assets/image-20250513163012063.png)

**3.使用C51扩展关键字_at_实现对绝对地址的访问：**

![image-20250513163213710](assets/image-20250513163213710.png)

## C51的中断函数及输入输出：

 ![image-20250513163412243](assets/image-20250513163412243.png)

![image-20250513163517186](assets/image-20250513163517186.png)

![image-20250513164745268](assets/image-20250513164745268.png)

# 2.51单片机内部资源及编程

## 2.1.单片机的并口：

![image-20250513171749055](assets/image-20250513171749055.png)

![image-20250513171911211](assets/image-20250513171911211.png)

### P0口作为I/O端口输出的时候

**P0.0给1：**内部总线给1，P0.0引脚最终浮动，相当于1

![image-20250513172810867](assets/image-20250513172810867.png)

**P0.0给0：**内部总线给0，P0.0引脚最终接地，相当于0

![image-20250513173004567](assets/image-20250513173004567.png)

**P0口在做I/O端口输出的时候，需要接上拉电阻。**

**内部总线给1和0，导致引脚浮动和接地。需要稳定的输出1和0，就需要加上上拉电阻。**

![image-20250513173251916](assets/image-20250513173251916.png)

### P0口作为I/O端口输入的时候

![image-20250513173855673](assets/image-20250513173855673.png)

**读锁存器：**

![image-20250513174026365](assets/image-20250513174026365.png)

### P0口作为地址/数据服用口的时候

**地址或者数据为0：**输出为0

![image-20250513174335052](assets/image-20250513174335052.png)

**地址或者数据为1：**输出为1

![image-20250513174607656](assets/image-20250513174607656.png)

![image-20250513174432913](assets/image-20250513174432913.png)

**输入数据->数据总线：**

![image-20250513174708933](assets/image-20250513174708933.png)

### P0总结：

![image-20250513174911027](assets/image-20250513174911027.png)

### P1口——准双向口，只能作通用I/O接口使用：

![image-20250513175810850](assets/image-20250513175810850.png)

![image-20250513175853693](assets/image-20250513175853693.png)

### P2口——准双向口，通用I/O接口、高8位地址线：

![image-20250513175946352](assets/image-20250513175946352.png)

### P3口——通用I/O接口、第二功能：

![image-20250513180136597](assets/image-20250513180136597.png)

![image-20250513180304884](assets/image-20250513180304884.png)

![image-20250513180324558](assets/image-20250513180324558.png)

### 并口总结：

![image-20250513181247084](assets/image-20250513181247084.png)

![image-20250513181445596](assets/image-20250513181445596.png)

![image-20250513191714279](assets/image-20250513191714279.png)

**P1引脚在读入的时候，写1之后，写锁存器就不再工作了，那么从引脚读到的状态就不会影响到寄存器的状态。**

#### 静态数码管

![image-20250513210400788](assets/image-20250513210400788.png)

![image-20250513210453381](assets/image-20250513210453381.png)

 ![image-20250513211105464](assets/image-20250513211105464.png)

![image-20250513211158277](assets/image-20250513211158277.png)

#### 流水灯

![image-20250513211610302](assets/image-20250513211610302.png)

![image-20250513212006225](assets/image-20250513212006225.png)

假设 `dat` 的初始值为 `0x01`（二进制 `00000001`），执行代码后的变化如下：

1. **第一次操作**：`00000001 → 00000010`（左移1位，最高位0 → 最低位0）。

2. **第二次操作**：`00000010 → 00000100`。

3. 

   持续操作

   ：二进制位依次左移，直到最高位为1时：

   - `dat = 0x80`（`10000000`） → 操作后变为 `0x01`（`00000001`）。

#### 读锁存器或读端口

![image-20250513213729114](assets/image-20250513213729114.png)

## 2.2.定时/计数器

![image-20250513214300164](assets/image-20250513214300164.png)

![image-20250513214948454](assets/image-20250513214948454.png)

![image-20250513215134550](assets/image-20250513215134550.png)

![image-20250513215356131](assets/image-20250513215356131.png)

计数频率最高为fosc/24的原因：

![image-20250513215459312](assets/image-20250513215459312.png)

![image-20250513215630890](assets/image-20250513215630890.png)

#### 定时/计数器的方式和控制寄存器

![image-20250513215836394](assets/image-20250513215836394.png)

![image-20250513215919391](assets/image-20250513215919391.png)

![image-20250513220019223](assets/image-20250513220019223.png)

![image-20250513220213182](assets/image-20250513220213182.png)

##### 方式0：

 ![image-20250513220354591](assets/image-20250513220354591.png)

![image-20250513220429769](assets/image-20250513220429769.png)

##### 方式1：

![image-20250513220624226](assets/image-20250513220624226.png)

![image-20250513220648351](assets/image-20250513220648351.png)

##### 方式2：适合做精确的计时，脉冲信号发生器。

![image-20250513220934729](assets/image-20250513220934729.png)

![image-20250513221044884](assets/image-20250513221044884.png)

##### 方式3：

当T0使用工作3方式，T1推荐使用工作2方式，可用作波特率发生器。

![image-20250513221814727](assets/image-20250513221814727.png)

####  定时/计数器的编程

1.确定定时/计数器方式，设置TMOD；不能安慰寻址，只能对字节整体设置。

2.计算定时/计数器的计数值->初值，写入初值寄存器（TH*,TL*）

3.中断初始化。

4.设置定时/计数器TCON，启动定时/计数器开始工作。



![image-20250515155645723](assets/image-20250515155645723.png)

![image-20250515160308947](assets/image-20250515160308947.png)

##### 定时/计数器的应用1

![image-20250515160727984](assets/image-20250515160727984.png)

问题分析：（使用T0模式2，TH0对TL0进行数据重装，不用在中断里赋初值）

![image-20250515161014175](assets/image-20250515161014175.png)

实现：采用查询方式：程序不断的对TF0标志进行查询，当它举旗的时候，执行引脚端口取反，注意：需要在循环体里对TF0置0。

![image-20250515161242441](assets/image-20250515161242441.png)

实现：采用中断方式：

![image-20250515161524594](assets/image-20250515161524594.png)

##### 定时/计数器的应用2

![image-20250515162046981](assets/image-20250515162046981.png)